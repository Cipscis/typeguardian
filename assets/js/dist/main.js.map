{"version":3,"file":"main.js","mappings":"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","sources":["webpack://typeguardian/./app/assets/js/src/ui/Selector.ts","webpack://typeguardian/./app/assets/js/src/ui/copy.ts","webpack://typeguardian/./app/assets/js/src/ui/toast.ts","webpack://typeguardian/./app/assets/js/src/ui/CssClass.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/writeTypeguardName.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/writeTypeguardExpression.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/writeIndentation.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/version.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/writeTypeguardFunction.ts","webpack://typeguardian/./app/assets/js/src/typeguardian/readTypeDef.ts","webpack://typeguardian/./app/assets/js/src/ui/generate.ts","webpack://typeguardian/./app/assets/js/src/ui/index.ts"],"sourcesContent":["import { EnumTypeOf } from '../util/EnumTypeOf.js';\r\n\r\n/**\r\n * Selectors used to interface with the DOM.\r\n */\r\nexport const Selector = {\r\n\tINSTANCE: '.js-typeguardian',\r\n\tINPUT: '.js-typeguardian__input',\r\n\tOUTPUT: '.js-typeguardian__output',\r\n\r\n\tGENERATE: '.js-typeguardian__generate',\r\n\tCOPY: '.js-typeguardian__copy',\r\n\r\n\tTOAST: '.js-toast',\r\n} as const;\r\nexport type Selector = EnumTypeOf<typeof Selector>;\r\n","import { Selector } from './Selector.js';\r\nimport { toast } from './toast.js';\r\n\r\n/**\r\n * Copy the current output from a TypeGuardian instance to the clipboard.\r\n */\r\nexport async function copy(this: HTMLElement): Promise<void> {\r\n\tconst $button = this;\r\n\tconst $instance = $button.closest(Selector.INSTANCE);\r\n\tif (!$instance) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst $output = $instance.querySelector(Selector.OUTPUT);\r\n\tif (!($output instanceof HTMLTextAreaElement)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst output = $output.value;\r\n\tawait navigator.clipboard.writeText(output);\r\n\r\n\ttoast('Copied!');\r\n}\r\n","import { Selector } from './Selector.js';\r\n\r\nexport function toast(message: string): void {\r\n\tconst $toast = document.querySelector<HTMLElement>(Selector.TOAST);\r\n\tif (!$toast) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t$toast.innerHTML = message;\r\n\t$toast.hidden = false;\r\n\r\n\tconst keyframes: Keyframe[] = [\r\n\t\t{\r\n\t\t\topacity: '0',\r\n\t\t},\r\n\t\t{\r\n\t\t\topacity: '1',\r\n\t\t\toffset: 0.2,\r\n\t\t},\r\n\t\t{\r\n\t\t\topacity: '1',\r\n\t\t\toffset: 0.8,\r\n\t\t},\r\n\t\t{\r\n\t\t\topacity: '0',\r\n\t\t},\r\n\t];\r\n\r\n\tconst animation = $toast.animate(keyframes, 5000);\r\n\r\n\tanimation.addEventListener('finish', (e) => {\r\n\t\t$toast.hidden = true;\r\n\t\t$toast.innerHTML = '';\r\n\t});\r\n}\r\n","import { EnumTypeOf } from '../util/EnumTypeOf.js';\r\n\r\n/**\r\n * CSS classes that are manipulated with JavaScript\r\n */\r\nexport const CssClass = {\r\n\tERROR: 'has-error',\r\n} as const;\r\nexport type CssClass = EnumTypeOf<typeof CssClass>;\r\n","/**\r\n * Write the name of a custom type's typeguard function in a systematic way.\r\n *\r\n * For example, the type `CustomType` would have a typeguard function `isCustomType`.\r\n */\r\nexport function writeTypeGuardName(typeName: string): string {\r\n\treturn `is${typeName}`;\r\n}\r\n","import { writeIndentation } from './writeIndentation.js';\r\nimport { writeTypeGuardName } from './writeTypeguardName.js';\r\n\r\n/**\r\n * Write a typeguard expression for a single type, i.e. not an object with properties.\r\n */\r\nexport function writeTypeguardExpression(propName: string, propType: string, indent = '    ', indentLevel = 0): string {\r\n\tconst baseIndent = writeIndentation(indent, indentLevel);\r\n\r\n\t/** These primitives can be checked via the `typeof` operator */\r\n\tconst typeofPrimitives = ['boolean', 'number', 'string', 'undefined'];\r\n\r\n\tconst unionSplitPattern = /\\s*\\|\\s*/;\r\n\r\n\t/** Array types can be specified via `Array<Type>` or `Type[]` */\r\n\tconst arrayPattern = /^(Array<(.+?)>|(.+?)\\[\\])$/;\r\n\r\n\t/** Name convention: custom types use PascalCase */\r\n\tconst customTypePattern = /^([A-Z][a-z]+)+$/;\r\n\r\n\t// `typeof` checks\r\n\tif (typeofPrimitives.includes(propType)) {\r\n\t\treturn `typeof data.${propName} === '${propType}'`;\r\n\t}\r\n\r\n\t// `null` checks\r\n\tif (propType === 'null') {\r\n\t\treturn `data.${propName} === null`;\r\n\t}\r\n\r\n\t// Array types\r\n\tconst arrayMatch = propType.match(arrayPattern);\r\n\tif (arrayMatch) {\r\n\t\tconst innerType = arrayMatch[2] ?? arrayMatch[3];\r\n\r\n\t\treturn `\r\n${baseIndent}${indent}Array.isArray(data.${propName}) &&\r\n${baseIndent}${indent}data.${propName}.every(${\r\n\tinnerType.match(customTypePattern)\r\n\t\t? writeTypeGuardName(innerType)\r\n\t\t: `() => ${writeTypeguardExpression(propName, innerType, indent, indentLevel + 1)}`\r\n})\r\n${baseIndent}`;\r\n\t}\r\n\r\n\t// Union types\r\n\t// TODO: Don't split on unions within an array type\r\n\tconst unionMembers = propType.split(unionSplitPattern);\r\n\r\n\tconst dedupedUnionMembers = [...new Set(unionMembers)];\r\n\tif (unionMembers.length !== dedupedUnionMembers.length) {\r\n\t\tconsole.warn(`WARNING: Duplicate union member detected in type ${propType}`);\r\n\t}\r\n\r\n\tif (unionMembers.length > 1) {\r\n\t\treturn `\r\n${baseIndent}${indent}${unionMembers.map((type) => writeTypeguardExpression(propName, type, indent, indentLevel + 1)).join(` ||\\n${baseIndent}${indent}`)}\r\n${baseIndent}`;\r\n\t}\r\n\r\n\t// Custom types\r\n\tconst isCustomType = (customTypePattern).test(propType);\r\n\tif (isCustomType) {\r\n\t\treturn `${writeTypeGuardName(propType)}(data.${propName})`;\r\n\t}\r\n\r\n\t// Unrecognised pattern, left to developer to implement\r\n\treturn `false /* TODO: implement typeguard for \\`${propName}: ${propType}\\`*/`;\r\n}\r\n","/**\r\n * Write a certain level of defined indentation.\r\n */\r\nexport function writeIndentation(indent = '    ', level = 0): string {\r\n\tconst indentLevels = new Array(level);\r\n\tindentLevels.fill(indent);\r\n\r\n\treturn indentLevels.join('');\r\n}\r\n","export const version = '1.0.0';\r\n","import { TypeDef } from './TypeDef.js';\r\nimport { readTypeDef } from './readTypeDef.js';\r\nimport { writeTypeguardExpression } from './writeTypeguardExpression.js';\r\nimport { version } from './version.js';\r\n\r\n/**\r\n * Write a typeguard function for an object type with properties.\r\n *\r\n * This function is intended to be used for generating code, not actually run within the browser.\r\n */\r\nexport function writeTypeguardFunction(typedef: TypeDef, indent?: string): string\r\nexport function writeTypeguardFunction(typedefString: string, indent?: string): string\r\nexport function writeTypeguardFunction(typedefArg: TypeDef | string, indent = '    '): string {\r\n\tconst typedef = typeof typedefArg === 'string' ? readTypeDef(typedefArg) : typedefArg;\r\n\r\n\tconst {\r\n\t\tname,\r\n\t\tprops,\r\n\t} = typedef;\r\n\r\n\tconst typeguard = `/**\r\n * Typeguard function for {@linkcode ${name}}\r\n *\r\n * Generated with {@link TypeGuardian https://cipscis.github.io/typeguardian} v${version}\r\n */\r\nfunction is${name}(testData: unknown): testData is ${name} {\r\n${indent}const data = testData as ${name};\r\n\r\n${indent}if (!(\r\n${indent}${indent}typeof data === 'object' &&\r\n${indent}${indent}data !== null\r\n${indent})) {\r\n${indent}${indent}return false;\r\n${indent}}\r\n\r\n${indent}${props.map(([propName, propType]) => `if (!(${writeTypeguardExpression(propName, propType, indent, 1)})) {\r\n${indent}${indent}return false;\r\n${indent}}`).join(`\\n\\n${indent}`)}\r\n\r\n${indent}return true;\r\n}`;\r\n\r\n\treturn typeguard;\r\n}\r\n","import { TypeDef } from './TypeDef.js';\r\n\r\n/**\r\n * Read in a type definition, and convert it to a `TypeDef` that can be used in code.\r\n *\r\n * It assumes all type or interface definitions will meet these criteria:\r\n *\r\n * - The type's name is on the first line\r\n * - The following lines each describe one property each\r\n * - The last line is a closing brace and can be ignored\r\n */\r\nexport function readTypeDef(typedef: string): TypeDef {\r\n\tconst lineCommentPattern = /^\\/\\//;\r\n\tconst blockCommentPattern = /^\\/?\\*/;\r\n\r\n\tconst lines = typedef.split('\\n')\r\n\t\t.map((line) => line.trim())\r\n\t\t.filter((line) => {\r\n\t\t\tconst isEmpty = line === '';\r\n\t\t\tif (isEmpty) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tconst isLineComment = lineCommentPattern.test(line);\r\n\t\t\tif (isLineComment) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tconst isInBlockComment = blockCommentPattern.test(line);\r\n\t\t\tif (isInBlockComment) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\tif (lines.length === 0) {\r\n\t\tthrow new Error(`Couldn't read empty type definition`);\r\n\t}\r\n\r\n\tconst nameMatch = lines[0].match(/^(export\\s+)?(type|interface)\\s+(\\w+)\\s*=\\s*{(\\s*\\/\\/.*)?$/);\r\n\tif (!nameMatch) {\r\n\t\tthrow new Error(`Couldn't determine name of custom type`);\r\n\t}\r\n\tconst name = nameMatch[3];\r\n\r\n\t// Ignore first and last line\r\n\tconst propLines = lines.slice(1, -1);\r\n\tconst props = propLines.map((line, lineNumber) => {\r\n\t\tconst isLineComment = (lineCommentPattern).test(line);\r\n\t\tif (isLineComment) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// This is not a proper test, just assuming block comments will use JSDoc style\r\n\t\tconst isInBlockComment = (blockCommentPattern).test(line);\r\n\t\tif (isInBlockComment) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst lineMatch = line.match(/^(\\w+)\\s*(\\??:)\\s*(.+?)(,|;)?(\\s*\\/\\/.*)?$/);\r\n\r\n\t\tif (!lineMatch) {\r\n\t\t\tthrow new Error(`Couldn't read property on line ${lineNumber} of ${name} definition: ${line}`);\r\n\t\t}\r\n\r\n\t\tconst propName = lineMatch[1];\r\n\t\tconst isOptional = lineMatch[2] === '?:';\r\n\t\tconst propType = `${lineMatch[3]}${isOptional ? ' | undefined' : ''}`;\r\n\r\n\t\treturn [propName, propType] as [string, string];\r\n\t}).filter((el): el is NonNullable<typeof el> => Boolean(el));\r\n\r\n\treturn {\r\n\t\tname,\r\n\t\tprops,\r\n\t};\r\n}\r\n","import { writeTypeguardFunction } from '../typeguardian/writeTypeguardFunction.js';\r\nimport { CssClass } from './CssClass.js';\r\nimport { Selector } from './Selector.js';\r\n\r\n/**\r\n * Generate a typeguard function from input in the UI, and display it.\r\n */\r\nexport function generate(this: HTMLElement): void {\r\n\tconst $button = this;\r\n\tconst $instance = $button.closest(Selector.INSTANCE);\r\n\tif (!$instance) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst $input = $instance.querySelector(Selector.INPUT);\r\n\tif (!($input instanceof HTMLTextAreaElement)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst $output = $instance.querySelector(Selector.OUTPUT);\r\n\tif (!($output instanceof HTMLTextAreaElement)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst input = $input.value;\r\n\r\n\ttry {\r\n\t\tconst output = writeTypeguardFunction(input);\r\n\r\n\t\t$output.value = output;\r\n\t\t$output.classList.remove(CssClass.ERROR);\r\n\t} catch (e) {\r\n\t\tconst message = e instanceof Error ? e.message : String(e);\r\n\r\n\t\t$output.value = message;\r\n\t\t$output.classList.add(CssClass.ERROR);\r\n\t}\r\n}\r\n","import { copy } from './copy.js';\r\nimport { CssClass } from './CssClass.js';\r\nimport { generate } from './generate.js';\r\nimport { Selector } from './Selector.js';\r\n\r\n/**\r\n * Initialise the TypeGuardian UI.\r\n */\r\nexport function init(): void {\r\n\tinitEvents();\r\n}\r\n\r\nfunction initEvents(): void {\r\n\tdocument.querySelectorAll<HTMLElement>(Selector.GENERATE).forEach((el) => el.addEventListener('click', generate));\r\n\tdocument.addEventListener('keydown', (e) => {\r\n\t\tconst $input = document.querySelector<HTMLElement>(Selector.INPUT);\r\n\t\tif (!$input) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst $output = document.querySelector<HTMLElement>(Selector.OUTPUT);\r\n\t\tif (!$output) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {\r\n\t\t\tgenerate.call($input);\r\n\t\t\tif (!$output.classList.contains(CssClass.ERROR)) {\r\n\t\t\t\tcopy.call($input);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tdocument.querySelectorAll<HTMLElement>(Selector.COPY).forEach((el) => el.addEventListener('click', copy));\r\n}\r\n"],"names":["Selector","INSTANCE","INPUT","OUTPUT","GENERATE","COPY","TOAST","async","copy","$instance","this","closest","$output","querySelector","HTMLTextAreaElement","output","value","navigator","clipboard","writeText","message","$toast","document","innerHTML","hidden","animate","opacity","offset","addEventListener","e","toast","CssClass","ERROR","writeTypeGuardName","typeName","writeTypeguardExpression","propName","propType","indent","indentLevel","baseIndent","level","indentLevels","Array","fill","join","writeIndentation","customTypePattern","includes","arrayMatch","match","innerType","unionMembers","split","dedupedUnionMembers","Set","length","console","warn","map","type","test","version","writeTypeguardFunction","typedefArg","typedef","lineCommentPattern","blockCommentPattern","lines","line","trim","filter","Error","nameMatch","name","props","slice","lineNumber","lineMatch","isOptional","el","Boolean","readTypeDef","generate","$input","input","classList","remove","String","add","querySelectorAll","forEach","key","ctrlKey","metaKey","call","contains"],"sourceRoot":""}